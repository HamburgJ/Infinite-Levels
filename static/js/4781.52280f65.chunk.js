"use strict";(self.webpackChunklevel_game=self.webpackChunklevel_game||[]).push([[4781],{4781:(n,e,o)=>{o.d(e,{A:()=>c});var t=o(9950),i=o(7226),a=o(3437),r=o(9530),l=o(4414);const c=n=>{let{shaderType:e=r.Co.DEFAULT}=n;const o=(0,t.useRef)(),c=(0,t.useRef)(),s=(0,t.useRef)(),p=(0,t.useRef)(),m=(0,t.useRef)(),f=(0,t.useRef)(0),v=(0,t.useRef)();return(0,t.useEffect)((()=>{const n=(()=>{const n=new i.Z58;c.current=n;const t=new i.qUd(-1,1,1,-1,0,1);s.current=t;const l=new a.JeP({antialias:!0});l.setSize(window.innerWidth,window.innerHeight),o.current.appendChild(l.domElement),p.current=l;const f=new i.bdM(2,2),v=(0,r.v_)(e);console.log("Using shader type:",e);const d=new i.BKk({vertexShader:r.B6,fragmentShader:v,uniforms:{iTime:{value:0},iResolution:{value:new i.I9Y(window.innerWidth,window.innerHeight)},iMouse:{value:new i.I9Y(0,0)}}});m.current=d;const u=new i.eaF(f,d);n.add(u);const h=n=>{m.current&&(m.current.uniforms.iMouse.value.x=n.clientX,m.current.uniforms.iMouse.value.y=n.clientY)};window.addEventListener("mousemove",h);const g=()=>{p.current&&m.current&&(p.current.setSize(window.innerWidth,window.innerHeight),m.current.uniforms.iResolution.value.x=window.innerWidth,m.current.uniforms.iResolution.value.y=window.innerHeight)};return window.addEventListener("resize",g),()=>{window.removeEventListener("mousemove",h),window.removeEventListener("resize",g)}})(),t=()=>{v.current=requestAnimationFrame(t),f.current+=.01,m.current&&(m.current.uniforms.iTime.value=f.current),p.current&&c.current&&s.current&&p.current.render(c.current,s.current)};return t(),()=>{if(v.current&&cancelAnimationFrame(v.current),p.current){var e;p.current.dispose();const n=p.current.domElement;null===(e=n.parentNode)||void 0===e||e.removeChild(n)}n()}}),[e]),(0,l.jsx)("div",{ref:o,style:{width:"100%",height:"100%"}})}},9530:(n,e,o)=>{o.d(e,{Co:()=>t,B6:()=>i,v_:()=>r});const t={DEFAULT:"DEFAULT",WORMHOLE:"WORMHOLE",HYPERDIMENSIONAL:"HYPERDIMENSIONAL",PARTICLE_FLOW:"PARTICLE_FLOW",GEOMETRIC_PATTERNS:"GEOMETRIC_PATTERNS",FRACTAL_BOXES:"FRACTAL_BOXES",DNA_VISUALIZER:"DNA_VISUALIZER",SIERPINSKI_ZOOM:"SIERPINSKI_ZOOM",ORGANIC_FLOW:"ORGANIC_FLOW"};console.log("Shader types:",t);const i="\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n",a="\n    uniform float iTime;\n    uniform vec2 iResolution;\n    \n    void main() {\n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        gl_FragColor = vec4(uv.x, uv.y, 0.5 + 0.5 * sin(iTime), 1.0);\n    }\n";console.log("Default shaders loaded");console.log("Wormhole shader loaded");const r=n=>{switch(console.log("Getting shader for type:",n),n){case t.DEFAULT:return a;case t.WORMHOLE:return"\n    uniform float iTime;\n    uniform vec2 iResolution;\n    uniform vec2 iMouse;\n    \n    #define pi 3.14159\n    \n    mat2 Rot(float a) {\n        float c = cos(a), s = sin(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec2 swirl(vec2 p, vec2 center, float r) {\n        vec2 diff = p - center;\n        float d = length(diff);\n        float angle = 2.0 * pi * (1.0 - exp(-d/r));\n        float c = cos(angle), s = sin(angle);\n        vec2 rotated = vec2(diff.x*c - diff.y*s, diff.x*s + diff.y*c);\n        return center + rotated;\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec2 ms = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        ms *= 0.4;\n        \n        vec2 swirlUv = swirl(uv, ms, 0.8);\n        uv = mix(uv, swirlUv, 0.7);\n        \n        float A = 1.0;\n        float r = 0.3;\n        float th = 0.02;\n        \n        vec2 dir = uv - ms;\n        float a = atan(dir.x, dir.y);\n        float s = 0.0;\n        \n        float n = 5.0;\n        float k = 6.0/iResolution.y;\n        \n        for (float i = n; i > 0.0; i--) {\n            float io = A * 2.0 * pi * i / n;\n            float sc = -2.0 - 0.5 * i + 1.45 * cos(io - 9.0 * length(dir) + iTime * 2.7);\n            vec2 fpos = fract(sc * uv + 0.5 * i * ms) - 0.5;\n            fpos *= Rot(a);\n            float d = abs(fpos.x);\n            s *= 0.865;\n            s += step(0.0, s) * smoothstep(-k, k, -abs(d - r) + th);\n        }\n        \n        float val = s * 0.1 + 0.72 + 0.0 * iTime - 0.23 * pow(dot(dir,dir), 0.25);\n        val = clamp(val, 0.4, 1.0);\n        vec3 e = vec3(1.0);\n        vec3 col = 0.5 * pal(val, e, e, e, 0.24 * vec3(0.0,1.0,2.0)/3.0);\n        col = smoothstep(0.0, 1.0, col);\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.HYPERDIMENSIONAL:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    // 4D rotation matrices\n    mat4 rotateXY(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            c,-s, 0, 0,\n            s, c, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        );\n    }\n    \n    mat4 rotateXZ(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            c, 0,-s, 0,\n            0, 1, 0, 0,\n            s, 0, c, 0,\n            0, 0, 0, 1\n        );\n    }\n    \n    mat4 rotateXW(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            c, 0, 0,-s,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            s, 0, 0, c\n        );\n    }\n    \n    mat4 rotateYZ(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            1, 0, 0, 0,\n            0, c,-s, 0,\n            0, s, c, 0,\n            0, 0, 0, 1\n        );\n    }\n    \n    mat4 rotateYW(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            1, 0, 0, 0,\n            0, c, 0,-s,\n            0, 0, 1, 0,\n            0, s, 0, c\n        );\n    }\n    \n    mat4 rotateZW(float a) {\n        float c = cos(a), s = sin(a);\n        return mat4(\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, c,-s,\n            0, 0, s, c\n        );\n    }\n    \n    // 4D noise\n    float noise4D(vec4 p) {\n        vec4 i = floor(p);\n        vec4 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        \n        float n = i.x + i.y * 157.0 + 113.0 * i.z + i.w * 571.0;\n        vec4 v = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n        \n        return mix(\n            mix(\n                mix(\n                    mix(v.x, v.y, f.w),\n                    mix(v.z, v.w, f.w),\n                    f.z),\n                mix(\n                    mix(v.y, v.z, f.w),\n                    mix(v.w, v.x, f.w),\n                    f.z),\n                f.y),\n            mix(\n                mix(\n                    mix(v.z, v.w, f.w),\n                    mix(v.x, v.y, f.w),\n                    f.z),\n                mix(\n                    mix(v.w, v.x, f.w),\n                    mix(v.y, v.z, f.w),\n                    f.z),\n                f.y),\n            f.x);\n    }\n    \n    // Smooth looping time\n    float loopTime(float t, float length) {\n        return t - floor(t / length) * length;\n    }\n    \n    float smoothLoop(float t, float length) {\n        float lt = loopTime(t, length);\n        return lt + smoothstep(length - 0.2, length, lt) * -lt;\n    }\n    \n    // 4D distance function\n    float sdf4D(vec4 p) {\n        float time = iTime * 0.2;\n        \n        // Smooth looping rotations\n        float t1 = smoothLoop(time * 0.5, PI * 2.0);\n        float t2 = smoothLoop(time * 0.4, PI * 2.0);\n        float t3 = smoothLoop(time * 0.3, PI * 2.0);\n        float t4 = smoothLoop(time * 0.2, PI * 2.0);\n        float t5 = smoothLoop(time * 0.1, PI * 2.0);\n        float t6 = smoothLoop(time * 0.6, PI * 2.0);\n        \n        // Apply 4D rotations with smooth transitions\n        mat4 rot = rotateXY(t1) *\n                  rotateXZ(t2) *\n                  rotateXW(t3) *\n                  rotateYZ(t4) *\n                  rotateYW(t5) *\n                  rotateZW(t6);\n        \n        vec4 p2 = rot * vec4(p.xyz, 1.0);\n        p2.w = p.w;\n        \n        // Create smooth morphing 4D shapes\n        float morph = smoothstep(-1.0, 1.0, sin(time * 0.3));\n        float sphere = length(p2.xyz) - 1.0;\n        float torus = length(vec2(length(p2.xy) - 1.5, p2.z)) - 0.3;\n        float hyperSphere = length(p2) - 1.5;\n        \n        float shape = mix(\n            mix(sphere, torus, morph),\n            hyperSphere,\n            smoothstep(-0.5, 0.5, sin(time * 0.2))\n        );\n        \n        // Add smooth noise distortion\n        float noise = noise4D(p2 * 2.0 + vec4(time * 0.2)) * 0.3;\n        \n        return shape + noise;\n    }\n    \n    // Enhanced color based on 4D position\n    vec3 colorize(vec4 p, float d) {\n        float time = iTime * 0.2;\n        \n        // Create vivid base colors\n        vec3 col1 = vec3(1.0, 0.2, 0.1); // Red\n        vec3 col2 = vec3(0.2, 1.0, 0.3); // Green\n        vec3 col3 = vec3(0.1, 0.3, 1.0); // Blue\n        \n        // Create dynamic color mixing\n        float a1 = atan(p.y, p.x);\n        float a2 = atan(p.z, p.w);\n        float blend1 = smoothstep(-PI, PI, a1);\n        float blend2 = smoothstep(-PI, PI, a2);\n        \n        vec3 col = mix(\n            mix(col1, col2, blend1),\n            col3,\n            blend2\n        );\n        \n        // Add depth-based coloring\n        col *= 1.0 - exp(-abs(d) * 2.0);\n        \n        // Add highlight for surface\n        float surf = 1.0 - smoothstep(0.0, 0.01, abs(d));\n        col += vec3(1.0, 0.9, 0.8) * surf * 0.5;\n        \n        // Add vibrant glow\n        float glow = exp(-d * d * 4.0);\n        col += mix(\n            vec3(0.8, 0.2, 0.5),\n            vec3(0.2, 0.5, 1.0),\n            sin(time * 0.5) * 0.5 + 0.5\n        ) * glow * 0.5;\n        \n        return col;\n    }\n    \n    // Draw 4D axis line\n    float draw4DAxis(vec4 p, vec4 dir, vec3 color, inout vec3 outColor) {\n        // Project 4D line onto 3D view space\n        vec4 projected = p - dir * dot(p, dir);\n        float d = length(projected) / length(dir);\n        \n        // Create tapering effect based on w coordinate\n        float wFade = exp(-abs(p.w) * 0.5);\n        float intensity = (1.0 - smoothstep(0.0, 0.02, d)) * wFade;\n        \n        // Add pulsing glow effect\n        float pulse = 0.8 + 0.2 * sin(iTime * 2.0 + dot(p, dir) * 3.0);\n        outColor = mix(outColor, color * pulse, intensity * 0.8);\n        return intensity;\n    }\n    \n    // Draw 4D coordinate axes\n    void draw4DAxes(vec4 p, inout vec3 col) {\n        // X axis (red)\n        draw4DAxis(p, vec4(1,0,0,0), vec3(1,0,0), col);\n        \n        // Y axis (green)\n        draw4DAxis(p, vec4(0,1,0,0), vec3(0,1,0), col);\n        \n        // Z axis (blue)\n        draw4DAxis(p, vec4(0,0,1,0), vec3(0,0,1), col);\n        \n        // W axis (yellow)\n        draw4DAxis(p, vec4(0,0,0,1), vec3(1,1,0), col);\n        \n        // Add intersection highlights at the origin\n        float originDist = length(p);\n        float highlight = exp(-originDist * 5.0);\n        col = mix(col, vec3(1), highlight * 0.3);\n        \n        // Add axis endpoint markers\n        float endpointSize = 0.1;\n        vec4 endpoints[4] = vec4[4](\n            vec4(1,0,0,0),\n            vec4(0,1,0,0),\n            vec4(0,0,1,0),\n            vec4(0,0,0,1)\n        );\n        vec3 endpointColors[4] = vec3[4](\n            vec3(1,0,0),  // X\n            vec3(0,1,0),  // Y\n            vec3(0,0,1),  // Z\n            vec3(1,1,0)   // W\n        );\n        \n        for(int i = 0; i < 4; i++) {\n            float endpointDist = length(p - endpoints[i]);\n            float marker = exp(-endpointDist * 10.0);\n            col = mix(col, endpointColors[i], marker * 0.5);\n        }\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        // Setup 4D ray with adjusted camera position for better axis visibility\n        vec4 ro = vec4(2.0, 2.0, -4.0, 1.0);\n        vec4 rd = normalize(vec4(uv, 2.0, -0.5));\n        \n        // Rotate camera in 4D to show the w-axis better\n        float camTime = iTime * 0.2;\n        mat4 camRot = rotateXW(sin(camTime) * 0.3) * \n                     rotateYW(cos(camTime) * 0.2) *\n                     rotateZW(sin(camTime * 0.7) * 0.1);\n        ro = camRot * ro;\n        rd = camRot * rd;\n        \n        // Ray march through 4D space\n        float t = 0.0;\n        float d = 0.0;\n        vec3 col = vec3(0.0);\n        \n        for(int i = 0; i < 100; i++) {\n            vec4 p = ro + rd * t;\n            d = sdf4D(p);\n            \n            // Draw 4D axes before surface\n            draw4DAxes(p, col);\n            \n            if(d < 0.001) {\n                col = mix(col, colorize(p, d), 0.6);\n                break;\n            }\n            \n            // Accumulate color through space with enhanced glow\n            col += colorize(p, d) * 0.01;\n            \n            t += max(abs(d) * 0.5, 0.02);\n            if(t > 10.0) break;\n        }\n        \n        // Enhanced color processing\n        col = pow(col, vec3(0.8)); // Gamma correction\n        col = col / (1.0 + col); // Tone mapping\n        col = mix(col, smoothstep(0.0, 1.0, col), 0.3); // Contrast\n        col = mix(col, col * col, 0.3); // Saturation boost\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.PARTICLE_FLOW:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    // Fast hash without sine\n    float hash(float n) {\n        n = fract(n * 8.1234567);\n        n *= (n + 33.33);\n        return fract(n * n);\n    }\n    \n    // Optimized color wheel\n    vec3 colorWheel(float angle) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.0, 0.33, 0.67);\n        \n        angle = mod(angle, 2.0 * PI) / (2.0 * PI);\n        \n        return a + b * cos(6.28318 * (c * angle + d));\n    }\n    \n    // Fast 3D value noise\n    float noise(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        \n        float n = i.x + i.y * 157.0 + 113.0 * i.z;\n        vec4 v1 = fract(vec4(n) * vec4(0.1031, 0.103, 0.0973, 0.1099));\n        vec4 v2 = fract(vec4(n + 157.0) * vec4(0.1031, 0.103, 0.0973, 0.1099));\n        \n        float x1 = mix(v1.x, v1.y, f.x);\n        float x2 = mix(v2.x, v2.y, f.x);\n        return mix(x1, x2, f.y);\n    }\n    \n    // Optimized FBM with fewer octaves\n    float fbm(vec3 p) {\n        float sum = 0.0;\n        float amp = 0.5;\n        p *= 2.0; // Scale up base frequency\n        \n        for(int i = 0; i < 3; i++) { // Reduced from 6 to 3 octaves\n            sum += noise(p) * amp;\n            amp *= 0.5;\n            p *= 2.0;\n            p.xy *= mat2(0.8, 0.6, -0.6, 0.8);\n        }\n        \n        return sum;\n    }\n    \n    // Simplified particle field\n    float particleField(vec3 p) {\n        float time = iTime * 0.2;\n        \n        // Single rotation for optimization\n        p.xz *= mat2(cos(time), sin(time), -sin(time), cos(time));\n        \n        // Single layer of particles with optimized movement\n        vec3 movement = vec3(\n            fbm(p * 0.5 + time * 0.3),\n            fbm(p * 0.4 - time * 0.2),\n            fbm(p * 0.6 + time * 0.4)\n        );\n        \n        p += movement * 1.5;\n        return fbm(p * 2.5) * 0.8;\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        float time = iTime * 0.2;\n        \n        // Optimized ray setup\n        vec3 ro = vec3(0.0, 0.0, -3.0);\n        vec3 rd = normalize(vec3(uv, 2.0));\n        \n        // Optimized ray march with fewer steps\n        float t = 0.0;\n        float density = 0.0;\n        \n        for(int i = 0; i < 32; i++) { // Reduced from 64 to 32 steps\n            vec3 p = ro + rd * t;\n            \n            // Simplified density accumulation\n            float particles = particleField(p);\n            density += particles * 0.15;\n            \n            t += 0.2; // Fixed step size for better performance\n            if(t > 6.0) break;\n        }\n        \n        // Dynamic color calculation\n        float angle = atan(uv.y, uv.x) + time;\n        angle += sin(length(uv) * 3.0 - time) * 0.3;\n        vec3 baseColor = colorWheel(angle);\n        \n        // Simplified secondary color\n        vec3 secondColor = colorWheel(angle + PI * 0.5);\n        baseColor = mix(baseColor, secondColor, 0.3);\n        \n        // Enhanced color output\n        vec3 col = baseColor * density * 2.5;\n        col += baseColor * exp(-density * 2.0) * 0.3;\n        \n        // Fast tone mapping\n        col = col / (1.0 + col);\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.GEOMETRIC_PATTERNS:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    // Sharp step function for crisp edges\n    float sharpStep(float edge, float x) {\n        float width = length(vec2(dFdx(x), dFdy(x))) * 0.5;\n        return smoothstep(edge - width, edge + width, x);\n    }\n    \n    // Looping time functions\n    float loopTime(float t, float length) {\n        return mod(t, length);\n    }\n    \n    float smoothLoop(float t, float length) {\n        float lt = loopTime(t, length);\n        return lt + smoothstep(length - 0.2, length, lt) * -lt;\n    }\n    \n    // Modified warping functions for smooth loops\n    vec2 sinWarp(vec2 p, float time, float freq, float amp) {\n        float t = smoothLoop(time, PI * 2.0);\n        return p + vec2(\n            sin(p.y * freq + t) * amp,\n            cos(p.x * freq + t) * amp\n        );\n    }\n    \n    vec2 spiralWarp(vec2 p, float time) {\n        float t = smoothLoop(time, PI * 2.0);\n        float angle = atan(p.y, p.x);\n        float radius = length(p);\n        float warp = sin(radius * 4.0 - t) * 0.1;\n        return p * (1.0 + warp);\n    }\n    \n    vec2 vortexWarp(vec2 p, float time) {\n        float t = smoothLoop(time, PI * 4.0);\n        float angle = atan(p.y, p.x);\n        float radius = length(p);\n        angle += radius * sin(t * 0.5) * 2.0;\n        return vec2(\n            radius * cos(angle),\n            radius * sin(angle)\n        );\n    }\n    \n    // Geometric patterns with dynamic warping\n    float lines(vec2 p, float scale, float time) {\n        p = sinWarp(p, time * 0.5, 3.0, 0.1);\n        p *= scale;\n        return sharpStep(0.5, abs(fract(p.x + p.y) - 0.5));\n    }\n    \n    float grid(vec2 p, float scale, float time) {\n        p = spiralWarp(p, time);\n        p *= scale;\n        vec2 fp = abs(fract(p) - 0.5);\n        return sharpStep(0.05, min(fp.x, fp.y));\n    }\n    \n    float triangles(vec2 p, float scale, float time) {\n        p = vortexWarp(p, time);\n        p *= scale;\n        vec2 fp = fract(p) - 0.5;\n        float d = abs(fp.x) + abs(fp.y);\n        return sharpStep(0.7, d);\n    }\n    \n    // Rotation matrix\n    mat2 rot2D(float angle) {\n        float s = sin(angle), c = cos(angle);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        float time = iTime * 0.2;\n        \n        // Layer 1: Base grid with spiral warp\n        vec2 p1 = uv;\n        p1 = spiralWarp(p1, time * 0.7);\n        float pattern = grid(p1, 4.0, time);\n        \n        // Layer 2: Rotating lines with sine warp\n        vec2 p2 = uv * rot2D(smoothLoop(time * 0.3, PI * 2.0));\n        p2 = sinWarp(p2, time, 2.0, 0.2);\n        float lines1 = lines(p2, 5.0, time * 0.8);\n        pattern = mix(pattern, lines1, 0.4);\n        \n        // Layer 3: Moving triangles with vortex warp\n        vec2 p3 = uv;\n        p3 = vortexWarp(p3, time * 0.5);\n        p3.x += sin(smoothLoop(time * 0.3, PI * 2.0) + p3.y * 2.0) * 0.2;\n        float tris = triangles(p3, 3.0, time);\n        pattern = mix(pattern, tris, 0.3);\n        \n        // Layer 4: Diagonal lines with combined warping\n        vec2 p4 = uv * rot2D(PI * 0.25);\n        p4 = sinWarp(p4, time * 0.4, 1.0, 0.1);\n        p4 = spiralWarp(p4, time * 0.3);\n        float diagonals = lines(p4, 20.0, time * 0.5);\n        pattern = mix(pattern, diagonals, 0.2);\n        \n        // Layer 5: Additional flowing grid\n        vec2 p5 = uv * rot2D(smoothLoop(time * 0.1, PI * 2.0));\n        p5 = vortexWarp(p5, time * 0.2);\n        float flowGrid = grid(p5, 8.0, time * 0.3);\n        pattern = mix(pattern, flowGrid, 0.15);\n        \n        // Create sharp contrast between white and grey\n        vec3 col = mix(vec3(0.2), vec3(0.95), pattern);\n        \n        // Add depth layers with dynamic warping\n        float depth = 0.0;\n        vec2 dp = sinWarp(uv, time * 0.6, 4.0, 0.05);\n        depth += grid(dp * 2.0, 8.0, time * 0.4) * 0.1;\n        \n        vec2 dp2 = spiralWarp(uv, time * 0.3);\n        depth += lines(dp2 * rot2D(smoothLoop(time * -0.2, PI * 2.0)), 10.0, time * 0.5) * 0.05;\n        \n        // Apply depth to darken some areas\n        col *= 1.0 - depth;\n        \n        // Add subtle highlight lines with warping\n        vec2 hp = vortexWarp(uv, time * 0.4);\n        float highlight = lines(hp * rot2D(smoothLoop(time * 0.1, PI * 2.0)), 15.0, time * 0.7) * 0.05;\n        col += vec3(highlight);\n        \n        // Ensure we stay in grey-scale range\n        col = clamp(col, vec3(0.15), vec3(0.95));\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.FRACTAL_BOXES:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    vec2 rotate(vec2 p, float angle) {\n      float c = cos(angle);\n      float s = sin(angle);\n      return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n    }\n    \n    float sdBox(vec2 p, vec2 b) {\n      vec2 d = abs(p) - b;\n      return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    }\n    \n    vec3 palette(float t) {\n      vec3 a = vec3(0.5, 0.5, 0.5);\n      vec3 b = vec3(0.5, 0.5, 0.5);\n      vec3 c = vec3(1.0, 1.0, 1.0);\n      vec3 d = vec3(0.263, 0.416, 0.557);\n      return a + b * cos(6.28318 * (c * t + d));\n    }\n    \n    void main() {\n      vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n      \n      // Accumulate colors\n      vec3 finalColor = vec3(0.0);\n      float finalAlpha = 0.0;\n      \n      // Fractal parameters\n      float scale = 1.0;\n      float angle = iTime * 0.2;\n      vec2 offset = vec2(\n        cos(iTime * 0.5) * 0.2,\n        sin(iTime * 0.3) * 0.2\n      );\n      \n      // Iterate to create fractal\n      for(int i = 0; i < 8; i++) {\n        // Transform space\n        vec2 p = uv * scale + offset;\n        p = rotate(p, angle * float(i + 1));\n        \n        // Create shape\n        float d = sdBox(p, vec2(0.5, 0.5));\n        float glow = 0.02 / (abs(d) + 0.01);\n        \n        // Add color\n        vec3 color = palette(float(i) * 0.1 + iTime * 0.1);\n        finalColor += color * glow;\n        finalAlpha += glow;\n        \n        // Modify parameters for next iteration\n        scale *= 1.2;\n        angle *= 1.1;\n        offset *= 1.1;\n      }\n      \n      // Normalize and apply some post-processing\n      finalColor /= finalAlpha;\n      finalColor = pow(finalColor, vec3(0.8)); // Gamma correction\n      \n      // Add some subtle pulsing\n      float pulse = 1.0 + sin(iTime * 2.0) * 0.1;\n      finalColor *= pulse;\n      \n      gl_FragColor = vec4(finalColor, 1.0);\n    }\n";case t.DNA_VISUALIZER:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.0\n    #define SURF_DIST 0.001\n    \n    mat2 rot2D(float a) {\n        float s = sin(a), c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    // Optimized noise function\n    float hash(vec3 p) {\n        p = fract(p * 0.3183099 + .1);\n        p *= 17.0;\n        return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n    }\n    \n    float noise(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        return mix(\n            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);\n    }\n    \n    vec3 palette(float t) {\n        vec3 a = vec3(0.2, 0.2, 0.3);\n        vec3 b = vec3(0.2, 0.2, 0.2);\n        vec3 c = vec3(2.0, 1.0, 0.5);\n        vec3 d = vec3(0.20, 0.25, 0.35);\n        return a + b * cos(2.0 * PI * (c * t + d));\n    }\n    \n    // Optimized DNA structure\n    float sdDNA(vec3 p) {\n        float time = iTime * 0.3;\n        float helix = MAX_DIST;\n        \n        vec3 pp = p;\n        pp.xz *= rot2D(pp.y * 0.5 + time);\n        \n        float radius = 2.0 + sin(pp.y * 0.5 + time) * 0.5;\n        float d = length(pp.xz) - radius;\n        float y = mod(pp.y * 2.0 + time * 2.0, 4.0) - 2.0;\n        helix = length(vec2(d, y)) - 0.2;\n        \n        return helix;\n    }\n    \n    // Optimized particle field\n    float particleField(vec3 p) {\n        vec3 pp = p;\n        float field = 0.0;\n        \n        // Reduced iterations for better performance\n        for(int i = 0; i < 2; i++) {\n            float scale = 1.0 + float(i) * 0.7;\n            pp = p * scale;\n            \n            pp.xz *= rot2D(iTime * (0.1 + float(i) * 0.05));\n            pp.xy *= rot2D(iTime * (0.15 + float(i) * 0.05));\n            \n            pp += noise(pp * 2.0 + iTime * 0.2) * 0.3;\n            \n            vec3 id = floor(pp + 0.5);\n            vec3 local = fract(pp + 0.5) - 0.5;\n            \n            float particle = length(local) - (0.05 + sin(iTime + hash(id) * 10.0) * 0.02);\n            \n            float dna = sdDNA(p);\n            particle += 0.05 * sin(dna * 5.0 + iTime);\n            \n            field += particle / (scale * 2.0);\n        }\n        \n        return field;\n    }\n    \n    float sceneSDF(vec3 p) {\n        return min(sdDNA(p), particleField(p));\n    }\n    \n    vec3 getNormal(vec3 p) {\n        float d = sceneSDF(p);\n        vec2 e = vec2(0.001, 0.0);\n        vec3 n = d - vec3(\n            sceneSDF(p - e.xyy),\n            sceneSDF(p - e.yxy),\n            sceneSDF(p - e.yyx)\n        );\n        return normalize(n);\n    }\n    \n    // Optimized ray marching with adaptive step size\n    float rayMarch(vec3 ro, vec3 rd) {\n        float d0 = 0.0;\n        float dS = 0.0;\n        \n        for(int i = 0; i < MAX_STEPS; i++) {\n            vec3 p = ro + d0 * rd;\n            dS = sceneSDF(p);\n            d0 += dS * 0.7; // Larger steps for faster convergence\n            if(abs(dS) < SURF_DIST || d0 > MAX_DIST) break;\n        }\n        \n        return d0;\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        float camTime = iTime * 0.2;\n        vec3 ro = vec3(cos(camTime) * 8.0, sin(camTime * 0.5) * 3.0, sin(camTime) * 8.0);\n        vec3 lookAt = vec3(0.0);\n        \n        vec3 forward = normalize(lookAt - ro);\n        vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n        vec3 up = cross(forward, right);\n        vec3 rd = normalize(forward + right * uv.x + up * uv.y);\n        \n        float d = rayMarch(ro, rd);\n        vec3 p = ro + rd * d;\n        \n        vec3 col = vec3(0.01);\n        \n        if(d < MAX_DIST) {\n            vec3 n = getNormal(p);\n            vec3 lightDir = normalize(vec3(2.0, 4.0, -3.0) - p);\n            \n            float diff = max(0.0, dot(n, lightDir)) * 0.3;\n            float spec = pow(max(0.0, dot(reflect(-lightDir, n), -rd)), 32.0) * 0.2;\n            float rim = pow(1.0 - max(0.0, dot(n, -rd)), 4.0) * 0.1;\n            \n            vec3 baseColor = palette(length(p) * 0.1 + iTime * 0.1);\n            baseColor *= 0.5;\n            baseColor += palette(dot(n, vec3(1.0)) * 0.3 + iTime * 0.2) * 0.3;\n            \n            float fluid = noise(p * 2.0 + iTime * 0.2);\n            baseColor *= 0.8 + fluid * 0.4;\n            \n            col = baseColor * (diff + 0.1) + spec + rim;\n        }\n        \n        // Optimized volumetric particles with fewer steps\n        float particleDepth = 0.0;\n        vec3 particlePos = ro;\n        \n        for(int i = 0; i < 4; i++) {\n            particleDepth += 2.0; // Larger steps\n            particlePos += rd * 2.0;\n            \n            float particles = particleField(particlePos);\n            float glow = exp(-particles * 3.0) * 0.03;\n            \n            vec3 particleColor = palette(particles + iTime * 0.2 + float(i) * 0.1);\n            col += particleColor * glow * (1.0 - particleDepth / 8.0);\n        }\n        \n        float fog = 1.0 - exp(-d * 0.05);\n        vec3 fogColor = palette(iTime * 0.05) * 0.02;\n        col = mix(col, fogColor, fog * 0.3);\n        \n        col = pow(col, vec3(0.9));\n        col *= 0.8;\n        col = smoothstep(0.0, 1.0, col);\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.SIERPINSKI_ZOOM:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    // Optimized hash function for randomization\n    float hash(float n) {\n        return fract(sin(n) * 43758.5453123);\n    }\n    \n    // Vivid color transitions without white\n    vec3 rainbow(float t) {\n        vec3 c = 0.6 + 0.1 * cos(PI * 2.0 * (t + vec3(0.0, 0.33, 0.67)));\n        return c * vec3(0.9, 0.5, 0.8); // Ensure colors stay vivid\n    }\n    \n    // Psychedelic color palette with no white/black\n    vec3 psychedelic(float t) {\n        vec3 a = vec3(0.6, 0.4, 0.5);  // Raised base colors\n        vec3 b = vec3(0.4, 0.5, 0.4);  // More color variation\n        vec3 c = vec3(1.5, 1.2, 1.0);  // Faster color cycling\n        vec3 d = vec3(0.2, 0.4, 0.3);  // Color offset for vibrancy\n        return 0.6 + 0.4 * cos(2.0 * PI * (c * t + d)); // Keep colors in vivid range\n    }\n    \n    // Sierpinski triangle distance function\n    float sierpinski(vec2 p, float scale) {\n        const int iterations = 8;\n        float r = 2.0;\n        \n        p *= scale;\n        float d = 0.0;\n        \n        for(int i = 0; i < iterations; i++) {\n            // Rotate point with varying speed\n            float angle = iTime * 0.2 + float(i) * 0.1;\n            p *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n            \n            // Fold space\n            p.x = abs(p.x);\n            p.y = abs(p.y);\n            \n            // Dynamic rotation\n            if(p.y > p.x) p = p.yx;\n            \n            // Scale and translate with more variation\n            p -= 1.0 + 0.1 * sin(iTime * 0.3);\n            p *= r;\n            \n            // Track distance for coloring with more detail\n            d += length(p) * pow(r, float(-i)) * (1.0 + 0.2 * sin(iTime + float(i)));\n        }\n        \n        return d;\n    }\n    \n    // Zoom cycle function\n    float getZoomCycle(float t) {\n        float cycleLength = 10.0; // Length of one complete out-in cycle\n        float normalizedTime = mod(t, cycleLength) / cycleLength;\n        \n        // First half of cycle: zoom out exponentially\n        // Second half: zoom back in\n        if(normalizedTime < 0.5) {\n            float zoomOut = normalizedTime * 2.0; // 0 to 1\n            return exp(zoomOut * 4.0); // Exponential zoom out\n        } else {\n            float zoomIn = (normalizedTime - 0.5) * 2.0; // 0 to 1\n            return exp(4.0 * (1.0 - zoomIn)); // Smooth zoom in from max\n        }\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        // Dynamic zoom parameters with new cycle\n        float time = iTime * 0.3;\n        float zoom = getZoomCycle(time);\n        \n        // Calculate vertex to zoom towards with smoother transitions\n        float vertexTime = floor(time * 0.2);\n        float vertexBlend = smoothstep(0.0, 1.0, fract(time * 0.2));\n        float vertexAngle = PI * 2.0 * (hash(vertexTime) + vertexBlend);\n        vec2 zoomTarget = vec2(cos(vertexAngle), sin(vertexAngle)) * 0.5;\n        \n        // Apply zoom transformation with enhanced distortion based on zoom level\n        vec2 p = uv;\n        float distortionAmount = 0.02 / (zoom * 0.5 + 0.5); // Distortion reduces with zoom\n        p += distortionAmount * vec2(sin(p.y * 4.0 + time), cos(p.x * 4.0 + time));\n        p = (p - zoomTarget) * zoom + zoomTarget;\n        \n        // Get fractal distance\n        float d = sierpinski(p, 1.0);\n        \n        // Create vivid color layers\n        vec3 col = rainbow(d * 0.15 + time * 0.2); // Start with vibrant base\n        \n        // Layer multiple color effects\n        vec3 color1 = rainbow(d * 0.1 + time);\n        vec3 color2 = psychedelic(d * 0.2 - time * 0.5);\n        vec3 color3 = rainbow(d * 0.05 - time * 0.3);\n        \n        // Dynamic color mixing\n        float mix1 = sin(d * 8.0 + time * 2.0) * 0.5 + 0.5;\n        float mix2 = cos(d * 6.0 - time * 1.5) * 0.5 + 0.5;\n        \n        // Combine colors ensuring vibrancy\n        col = mix(color1, color2, mix1);\n        col = mix(col, color3, mix2 * 0.5);\n        \n        // Add flowing color waves\n        col += rainbow(length(p) * 0.2 - time * 0.3) * 0.3;\n        \n        // Add pulsing patterns\n        float pulse = sin(time * 2.0) * 0.5 + 0.5;\n        col = mix(col, rainbow(d * 0.3 + time * 0.7), pulse * 0.3);\n        \n        // Ensure colors stay vivid\n        col = clamp(col, vec3(0.2), vec3(0.95));\n        col = pow(col, vec3(0.9)); // Slight contrast without losing saturation\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";case t.ORGANIC_FLOW:return"\n    uniform vec2 iResolution;\n    uniform float iTime;\n    \n    #define PI 3.14159265359\n    \n    // Ultra-smooth interpolation\n    float smootherstep(float x) {\n        x = clamp(x, 0.0, 1.0);\n        return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n    }\n    \n    vec3 smootherstep3(vec3 x) {\n        return vec3(\n            smootherstep(x.x),\n            smootherstep(x.y),\n            smootherstep(x.z)\n        );\n    }\n    \n    // Continuous periodic function\n    float cperiod(float x, float period) {\n        return (1.0 - cos(x * 2.0 * PI / period)) * 0.5;\n    }\n    \n    // Super smooth noise without discontinuities\n    float smoothNoise(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = smootherstep3(f);\n        \n        vec3 u = f * f * (3.0 - 2.0 * f);\n        \n        float n = i.x + i.y * 157.0 + 113.0 * i.z;\n        vec4 v = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n        \n        return mix(\n            mix(mix(v.x, v.y, u.x), mix(v.z, v.w, u.x), u.y),\n            mix(mix(v.z, v.w, u.x), mix(v.w, v.x, u.x), u.y),\n            u.z\n        );\n    }\n    \n    // Continuous FBM without sudden changes\n    float fbm(vec3 p) {\n        float sum = 0.0;\n        float amp = 0.5;\n        float freq = 1.0;\n        \n        // Fixed rotation matrix for consistency\n        mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);\n        \n        for(int i = 0; i < 6; i++) {\n            sum += smoothNoise(p * freq) * amp;\n            p.xy *= rot;\n            p.yz *= rot;\n            amp *= 0.5;\n            freq *= 2.0;\n        }\n        \n        return sum * 0.5 + 0.5;\n    }\n    \n    // Continuous color shift with more variation\n    vec3 colorShift(float time) {\n        vec3 shift = vec3(\n            cperiod(time * 0.4 + 0.0, 8.0),\n            cperiod(time * 0.5 + 2.0, 7.0),\n            cperiod(time * 0.6 + 4.0, 6.0)\n        );\n        return shift * 0.5 + 0.3;\n    }\n    \n    // More aggressive brightness normalization\n    vec3 normalizeColor(vec3 col) {\n        float maxBright = max(max(col.r, col.g), col.b);\n        float minBright = min(min(col.r, col.g), col.b);\n        \n        // Compress high values more aggressively\n        if(maxBright > 0.6) {\n            float factor = 0.6 + (maxBright - 0.6) * 0.3;\n            col *= factor / maxBright;\n        }\n        \n        // Ensure minimum saturation\n        if(maxBright > minBright) {\n            float sat = (maxBright - minBright) / maxBright;\n            if(sat < 0.2) {\n                col = mix(vec3(maxBright), col, 0.2 / sat);\n            }\n        }\n        \n        return clamp(col, vec3(0.1), vec3(0.7));\n    }\n    \n    // Modified color palette with controlled range\n    vec3 palette(float t, vec3 shift) {\n        t = fract(t);\n        t = smootherstep(t);\n        \n        vec3 a = vec3(0.4, 0.3, 0.3) + shift * 0.15;\n        vec3 b = vec3(0.3, 0.3, 0.4) + shift * 0.1;\n        vec3 c = vec3(0.6, 0.5, 0.4) + shift * 0.2;\n        vec3 d = shift * 0.6;\n        \n        vec3 col = a + b * cos(2.0 * PI * (c * t + d));\n        return normalizeColor(col);\n    }\n    \n    // Organic distortion field\n    vec2 organicDistort(vec2 p, float time) {\n        vec2 dp = vec2(\n            fbm(vec3(p * 1.2 + vec2(0.0, time * 0.1), time * 0.2)),\n            fbm(vec3(p * 1.2 + vec2(time * 0.1, 0.0), time * 0.2))\n        );\n        return p + dp * 0.15;\n    }\n    \n    void main() {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        float time = iTime * 0.15;\n        \n        // Apply organic distortion\n        vec2 p = organicDistort(uv, time);\n        \n        // Get continuous color shift with reduced range\n        vec3 shift = colorShift(time) * 0.8;\n        \n        // Create continuous base pattern\n        float pattern = 0.0;\n        \n        // Flowing organic patterns with reduced intensity\n        vec3 pos1 = vec3(p * 1.2, time * 0.2);\n        pattern += fbm(pos1) * 0.4;\n        \n        // Rotating patterns\n        float angle = atan(p.y, p.x);\n        float radius = length(p);\n        vec3 pos2 = vec3(\n            radius * cos(angle + time * 0.2),\n            radius * sin(angle + time * 0.2),\n            time * 0.3\n        );\n        pattern += fbm(pos2) * 0.3;\n        \n        // Dynamic surface patterns\n        vec3 pos3 = vec3(\n            p * 1.5 + vec2(\n                cperiod(time * 0.1, 1.0),\n                cperiod(time * 0.15, 1.0)\n            ),\n            time * 0.1\n        );\n        pattern += fbm(pos3) * 0.2;\n        \n        // Create rich color layers with controlled intensity\n        vec3 col = palette(pattern * 0.5 + time * 0.1, shift);\n        \n        // Add flowing color patterns\n        float flow = fbm(vec3(p * 1.0, time * 0.2));\n        vec3 flowCol = palette(flow + time * 0.15, shift);\n        col = normalizeColor(mix(col, flowCol, 0.3));\n        \n        // Add pulsing color variations with reduced intensity\n        float pulse = cperiod(time, 1.0) * 0.15 + 0.2;\n        vec3 pulseColor = palette(pattern * 0.3 + time * 0.2, shift);\n        col = normalizeColor(mix(col, pulseColor, smootherstep(pulse)));\n        \n        // Add subtle color details\n        float detail = fbm(vec3(p * 2.0, time * 0.1));\n        vec3 detailColor = palette(detail, shift * 0.7);\n        col = normalizeColor(mix(col, detailColor, 0.15));\n        \n        // Final subtle enhancement without increasing brightness\n        col = mix(col, col * col, 0.1);\n        col = smootherstep3(col);\n        col = normalizeColor(col);\n        \n        gl_FragColor = vec4(col, 1.0);\n    }\n";default:return console.warn("Unknown shader type:",n),a}}}}]);